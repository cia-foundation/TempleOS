ClassStruct *DbgFindFun(Ltf *l,I8 line_offset=0)
{
  I1 st[256],st2[256],*filename=l->filename.name;
  I8 line=l->cur_entry->y+1+line_offset;
  U8 i;
  SysHashEntry *temph;
  SysHashTable *h=Fs->hash_table;
  ClassStruct *tempc;
  DbgInfo *tempd;
  while (h) {
    for (i=0;i<=h->mask;i++) {
      temph=h->body[i];
      while (temph) {
	if (temph->type&HTT_FUNCTION) {
	  tempc=temph;
	  if (tempd=tempc->debug) {
	    StrCpy(st,tempc->source_link);
	    RemoveFirstSeg(st,":",st2);
	    RemoveLastSeg(st,",",st2);
	    if (!StrCmp(st,filename)) {
	      if (line>=tempd->min_line && line<=tempd->max_line)
		return tempc;
	    }
	  }
	}
	temph=temph->next;
      }
    }
    h=h->next;
  }
  return NULL;
}

void WatchLocals()
{
  TssStruct *tss=Fs->parent_tss,*dbg_tss=tss->dbg_tss;
  Ltf *l;
  ClassStruct *tempc;
  U8 j,sc,ch;
  while (TRUE) {
//    PutS("$$CL$$");
    LtfBottom(Fs->cur_ltf);
    if (l=dbg_tss->cur_ltf) {
      if (tempc=DbgFindFun(l,0)) {
	Preempt(OFF);
	ClassRep2(Fs->cur_ltf,tss->ebp,tempc->string,0,HTT_FUNCTION);
	Preempt(ON);
      }
    }
    if (ScanChar(&sc,&ch)) {
      j=jiffies+JIFFY_FREQ*5;
      LtfPutChar(Fs->cur_ltf,ch,sc,TRUE);
      do {
	if (ch==CH_CTRLQ || ch==CH_ESC) Exit;
	if (ScanChar(&sc,&ch)) {
	  j=jiffies+JIFFY_FREQ*5;
	  LtfPutChar(Fs->cur_ltf,ch,sc,TRUE);
	}
	Sleep(100);
      } while (jiffies<j);
    } else
      Sleep(100);
  }
}


void Dbg()
{
//  TssStruct *tss;

  Fs->dbg_tss=Spawn(&UserCmdLine,"Debug",Fs);

/***  Not ready for prime time
  tss=Spawn(&ServantUserCmdLine,"WATCH TASK",Fs);
  while (!Bt(&tss->task_flags,TSSf_IDLE))
    SwapInNext;
  Bts(&tss->crt_flags,CRTf_SHOW);
  QueueTaskRequest(tss,Fs,"WatchLocals;",(1<<TSSCf_EXIT_ON_COMPLETE));
****/
}


void ToggleBpt(Ltf *l,I8 line_offset=0,U8 flags=SBPTF_BPT)
{
  I1 st[256],st2[256],*filename=l->filename.name;
  I8 line=l->cur_entry->y+1+line_offset;
  SysHashEntry *temph;
  SysHashTable *h=Fs->hash_table;
  ClassStruct *tempc;
  U8 i,a;
  DbgInfo *tempd;
  LtfEntry *ll;
  while (h) {
    for (i=0;i<=h->mask;i++) {
      temph=h->body[i];
      while (temph) {
	if (temph->type&HTT_FUNCTION) {
	  tempc=temph;
	  if (tempd=tempc->debug) {
	    StrCpy(st,tempc->source_link);
	    RemoveFirstSeg(st,":",st2);
	    RemoveLastSeg(st,",",st2);
	    if (!StrCmp(st,filename)) {
	      if (line>=tempd->min_line && line<=tempd->max_line) {
		a=tempd->body[line-tempd->min_line];
		ll=l->cur_entry;
		while (ll->last->btype!=LTFT_CR &&
		       ll->last->btype!=LTFT_SOFT_CR &&
		       ll->last!=l)
		  ll=ll->last;
		l->cur_entry=ll;
		l->cur_data_col=ll->min_col;
		if (flags==SBPTF_BPT) {
		  if (!RBpt(Fs->parent_tss,a)) {
		    SBpt(Fs->parent_tss,a,flags);
		    Auto("$$BP$$");
		  } else {
		    if (ll->btype==LTFT_BPT) {
		      l->cur_entry=ll->next;
		      l->cur_data_col=l->cur_entry->min_col;
		      RemQue(ll);
		      LtfDelEntry(ll,l->mem_tss);
		    }
		  }
		} else {
		  if (!FindBpt(Fs->parent_tss,a,ALL_MASK,FALSE))
		    SBpt(Fs->parent_tss,a,flags);
		}
		if (line_offset) {
		  l->x=0;
		  l->y=line-1;
		  LtfUpdateWindowJoin(l,FALSE,FALSE,FALSE,TRUE);
		}
		return;
	      }
	    }
	  }
	}
	temph=temph->next;
      }
    }
    h=h->next;
  }
}

void ClearAllBpts(Ltf *l)
{
  LtfEntry *ll,*ll2;
  CBpt(Fs->parent_tss);
  ll=l->dummy.next;
  while (ll!=l) {
    ll2=ll->next;
    if (ll->btype==LTFT_BPT) {
      if (l->cur_entry==ll) {
	l->cur_entry=ll->next;
	l->cur_data_col=l->cur_entry->min_col;
      }
      RemQue(ll);
      LtfDelEntry(ll,l->mem_tss);
    }
    ll=ll2;
  }
}

void LtfGo()  //Continue after breakpoint
{
  TssStruct *tss=Fs->parent_tss;
  U4 *eip=&tss->eip;
  CBpt(tss,SBPTF_STEP);
  *eip-=1;
  DBpt(tss,*eip);
  Btr(&tss->task_flags,TSSf_SUSPENDED);
}

public void Go()  //Continue after breakpoint
{
  LtfGo;
  Exit;
}

public void Step()  //Single step (ASM)
{
  TssStruct *tss=Fs->parent_tss;
  U4 *eip=&tss->eip;
  I1 buf[256];
  U8 my_eip;
  CBpt(tss,SBPTF_STEP);
  *eip-=1;
  DBpt(tss,*eip);
  my_eip=*eip;
  DasmIns(buf,&my_eip);  //get addr of next ins start
  SBpt(tss,my_eip,SBPTF_STEP);
  Btr(&tss->task_flags,TSSf_SUSPENDED);
  Exit;
}

void LtfStep(Ltf *l)  //Single step
{
  TssStruct *tss=Fs->parent_tss;
  U4 *eip=&tss->eip;
  CBpt(tss,SBPTF_STEP);
  *eip-=1;
  DBpt(tss,*eip);
  ToggleBpt(l,1,SBPTF_STEP);
  Btr(&tss->task_flags,TSSf_SUSPENDED);
}

