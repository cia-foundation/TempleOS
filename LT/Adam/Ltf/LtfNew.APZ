U8 ltf_display_types[1],ltf_nondisplay_invisible_types[1],
      ltf_form_types[1],ltf_data_types[1];
U8 ltf_clean_scancodes[4]={0,0,0,0};

ltf_display_types[0]=
	1<<LTFT_TEXT|
	1<<LTFT_DATA|
	1<<LTFT_MENU_VALUE|
	1<<LTFT_HIDE_START |
	1<<LTFT_TREE|
	1<<LTFT_HIDE_END|
	1<<LTFT_MACRO|
	1<<LTFT_BUTTON|
	1<<LTFT_CHECK_BOX|
	1<<LTFT_LINK|
	1<<LTFT_ANCHOR|
	1<<LTFT_PICTURE|
	1<<LTFT_PICWORD|
	1<<LTFT_INSERT_BINARY|
	1<<LTFT_INSERT_BINARY_TYPE|
	1<<LTFT_INSERT_BINARY_SIZE|
	1<<LTFT_SONG;
ltf_nondisplay_invisible_types[0]=
  1<<LTFT_PAGE_LENGTH|
  1<<LTFT_LEFT_MARGIN|
  1<<LTFT_RIGHT_MARGIN|
  1<<LTFT_HEADER|
  1<<LTFT_FOOTER|
  1<<LTFT_INDENT|
  1<<LTFT_FOREGROUND_COLOR|
  1<<LTFT_BACKGROUND_COLOR|
  1<<LTFT_DEFAULT_FOREGROUND_COLOR|
  1<<LTFT_DEFAULT_BACKGROUND_COLOR|
  1<<LTFT_LINK_FOREGROUND|
  1<<LTFT_LINK_BACKGROUND|
  1<<LTFT_MACRO_FOREGROUND|
  1<<LTFT_MACRO_BACKGROUND|
  1<<LTFT_ANCHOR_FOREGROUND|
  1<<LTFT_ANCHOR_BACKGROUND|
  1<<LTFT_HIDDEN_FOREGROUND|
  1<<LTFT_HIDDEN_BACKGROUND|
  1<<LTFT_TREE_FOREGROUND|
  1<<LTFT_TREE_BACKGROUND|
  1<<LTFT_USER_FOREGROUND|
  1<<LTFT_USER_BACKGROUND|
  1<<LTFT_WORD_WRAP|
  1<<LTFT_UNDERLINED|
  1<<LTFT_INVERTED|
  1<<LTFT_BLINK|
  1<<LTFT_SHIFTED_X|
  1<<LTFT_SHIFTED_Y|
  1<<LTFT_PICTURE|
  1<<LTFT_PICWORD|
  1<<LTFT_TOP_LEFT_TOOLBAR|
  1<<LTFT_TOP_RIGHT_TOOLBAR|
  1<<LTFT_BPT;
ltf_form_types[0]=ltf_display_types[0] & ~(1<<LTFT_TEXT)|1<<LTFT_HEX_EDIT;
ltf_data_types[0]=1<<LTFT_DATA|
		  1<<LTFT_HEX_EDIT|
		  1<<LTFT_CHECK_BOX;

Bts(ltf_clean_scancodes,SC_CURSOR_RIGHT);
Bts(ltf_clean_scancodes,SC_CURSOR_LEFT);
Bts(ltf_clean_scancodes,SC_CURSOR_UP);
Bts(ltf_clean_scancodes,SC_CURSOR_DOWN);
Bts(ltf_clean_scancodes,SC_PAGE_UP);
Bts(ltf_clean_scancodes,SC_PAGE_DOWN);
Bts(ltf_clean_scancodes,SC_ALT);
Bts(ltf_clean_scancodes,SC_CTRL);
Bts(ltf_clean_scancodes,SC_SHIFT);
Bts(ltf_clean_scancodes,SC_CAPS);
Bts(ltf_clean_scancodes,SC_NUM);
Bts(ltf_clean_scancodes,SC_SCROLL);
Bts(ltf_clean_scancodes,SC_HOME);
Bts(ltf_clean_scancodes,SC_END);
Bts(ltf_clean_scancodes,SC_GUI);
Bts(ltf_clean_scancodes,SC_BACKSPACE); //Handled specially


LtfBinEntry *LtfFindBin(Ltf *l,U8 num)
{
  LtfBinEntry *b=l->bin_root.next;
  while (b!=&l->bin_root) {
    if (b->num==num)
      return b;
    b=b->next;
  }
  return NULL;
}

void LtfValidateBins(Ltf *l)
{
  LtfBinEntry *b=l->bin_root.next,*b1;
  LtfEntry *cl=l->dummy.next,*cl2;
  while (b!=&l->bin_root) {
    b->use_cnt=0;
    b->temp_use_cnt=0;
    b=b->next;
  }
  while (cl!=l) {
    cl2=cl->next;
    if (cl->flags & LTFLF_HAS_BIN) {
      if (cl->bin_data=LtfFindBin(l,cl->bin_num)) {
	cl->bin_data->use_cnt++;
	if (cl->btype==LTFT_PICWORD)
	  cl->bin_data->temp_use_cnt++;
      } else {
	DbgStr("Bin Not Found",3000);
	RemQue(cl); //don't attempt to delete
      }
    }
    cl=cl2;
  }
  b=l->bin_root.next;
  l->cur_bin_num=1;
  while (b!=&l->bin_root) {
    b1=b->next;
    if (!b->use_cnt) {
      RemQue(b);
      Free(b->data,l->mem_tss);
      Free(b,l->mem_tss);
    } else {
      if (b->num>=l->cur_bin_num)
	l->cur_bin_num=b->num+1;
    }
    b=b1;
  }
}


void LtfDelBin(Ltf *l,LtfBinEntry *b)
{
  b->use_cnt--;
  if (!b->use_cnt) {
    RemQue(b);
    Free(b->data,l->mem_tss);
    Free(b,l->mem_tss);
  }
}

void LtfDelEntry(Ltf *l,LtfEntry *cl)
{
  if (l==cl)
    DbgStr("Ltf Del Header",10000);
  else {
    if (l->cur_entry==cl)
      l->cur_entry=cl->next;
    if (l->top_entry==cl)
      l->top_entry=cl->next;
    RemQue(cl);
    if (Bt(ltf_display_types,cl->btype))
      Free(cl->display,l->mem_tss);
    if (cl->flags & LTFLF_LEFT_MACRO)
      Free(cl->left_macro,l->mem_tss);
    if (cl->flags & LTFLF_RIGHT_MACRO)
      Free(cl->right_macro,l->mem_tss);
    if (cl->flags & LTFLF_AUX_STR)
      Free(cl->aux_str,l->mem_tss);
    if (cl->flags & LTFLF_HAS_BIN)
      LtfDelBin(l,cl->bin_data);
    Free(cl,l->mem_tss);
  }
}

void LtfDelUndo(Ltf *l,LtfUndo *u)
{
  Free(u->body,l->mem_tss);
  Free(u,l->mem_tss);
}

void LtfSetUndoCnt(Ltf *l)
{
  BoolU4 old_preempt=Preempt(OFF);
  LtfUndo *u=l->undo_root.next;
  l->undo_cnt=0;
  while (u!=&l->undo_root) {
    l->undo_cnt++;
    u=u->next;
  }
  Preempt(old_preempt);
}

BoolU8 LtfCheckBin(Ltf *l,LtfBinEntry *b)
{
  if (MTss(b->data)!=l->mem_tss)
    return FALSE;
  if (MTss(b)!=l->mem_tss)
    return FALSE;
  return TRUE;
}

BoolU8 LtfCheckEntry(Ltf *l,LtfEntry *cl)
{
  if (l==cl)
    DbgStr("Ltf Del Header",10000);
  else {
    if (Bt(ltf_display_types,cl->btype))
      if (MTss(cl->display)!=l->mem_tss)
	return FALSE;
    if (cl->flags & LTFLF_LEFT_MACRO)
      if (MTss(cl->left_macro)!=l->mem_tss)
	return FALSE;
    if (cl->flags & LTFLF_RIGHT_MACRO)
      if (MTss(cl->right_macro)!=l->mem_tss)
	return FALSE;
    if (cl->flags & LTFLF_AUX_STR)
      if (MTss(cl->aux_str)!=l->mem_tss)
	return FALSE;
    if (cl->flags & LTFLF_HAS_BIN)
      if (!LtfCheckBin(l,cl->bin_data))
	return FALSE;
    if (MTss(cl)!=l->mem_tss)
      return FALSE;
  }
  return TRUE;
}


LtfEntry *LtfCopyEntry(Ltf *l,LtfEntry *cl)
{
  LtfEntry *nl;
  LtfBinEntry *tempb;
  TssStruct *tss=l->mem_tss;
  nl=MAllocIdentical(cl,tss);
  nl->next=nl;
  nl->last=nl;
  if (Bt(ltf_display_types,cl->btype))
    nl->display=MAllocIdentical(cl->display,tss);
  if (cl->flags & LTFLF_AUX_STR)
    nl->aux_str=MAllocIdentical(cl->aux_str,tss);
  if (cl->flags & LTFLF_LEFT_MACRO)
    nl->left_macro=MAllocIdentical(cl->left_macro,tss);
  if (cl->flags & LTFLF_RIGHT_MACRO)
    nl->right_macro=MAllocIdentical(cl->right_macro,tss);
  if (cl->flags & LTFLF_HAS_BIN) {
    tempb=MAllocIdentical(cl->bin_data,tss);
    tempb->data=MAllocIdentical(cl->bin_data->data,tss);
    nl->bin_num=l->cur_bin_num;
    tempb->num=l->cur_bin_num++;
    nl->bin_data=tempb;
    InsQue(tempb,l->bin_root.last);
  }
  return nl;
}

void LtfFormForward(Ltf *l)
{
  LtfEntry *cl=l->cur_entry,*cl1=cl->last,*cl2=cl;
  if (l->flags & LTFF_FORM) {
    while (cl!=cl1 && !Bt(ltf_form_types,cl->btype))
      cl=cl->next;
  }
  while (cl->btype==LTFT_INDENT)
    cl=cl->next;
  if (cl!=cl2) {
    l->cur_data_col=cl->min_col;
    l->cur_entry=cl;
  }
}

void LtfFormBackward(Ltf *l)
{
  LtfEntry *cl=l->cur_entry,*cl1=cl->next,*cl2=cl;
  if (l->flags & LTFF_FORM) {
    while (cl!=cl1 && !Bt(ltf_form_types,cl->btype))
      cl=cl->last;
  }
  while (cl->btype==LTFT_INDENT)
    cl=cl->next;
  if (cl!=cl2) {
    l->cur_data_col=cl->min_col;
    l->cur_entry=cl;
  }
}

public void LtfHome(Ltf *l=NULL)
{
  if (!l) {
    l=Fs->cur_ltf;
    if (!l) return;
  }
  l->cur_entry=l->dummy.next;
  l->cur_data_col=l->cur_entry->min_col;
  l->x=0;
  l->y=0;
  l->line_start_col=0;
  l->cur_top_line_num=0;
  LtfFormForward(l);
}

public BoolU4 LtfCheck(Ltf *l=NULL)
{
  LtfEntry *cl,*cl1;
  if (!l) {
    l=Fs->cur_ltf;
    if (!l) return FALSE;
  }
  cl=l->dummy.next;
  while (cl!=l) {
    cl1=cl->next;
    if (!LtfCheckEntry(l,cl))
      return FALSE;
    cl=cl1;
  }
  return TRUE;
}

public void LtfReset(Ltf *l,BoolU4 is_old)
{
  LtfEntry *cl,*cl1;
  LtfUndo *u,*u1;
  if (!l) {
    l=Fs->cur_ltf;
    if (!l) return;
  }
  if (is_old) {
    cl=l->dummy.next;
    while (cl!=l) {
      cl1=cl->next;
      LtfDelEntry(l,cl);
      cl=cl1;
    }
    u=l->undo_root.next;
    while (u!=&l->undo_root) {
      u1=u->next;
      LtfDelUndo(l,u);
      u=u1;
    }
  }
//Check $LK,"EditInsertLtf","MN:EditInsertLtf"$
  l->start_text_attribute=(WHITE<<4)+BLUE;
  l->text_attribute=l->start_text_attribute;
  l->link_attribute=(WHITE<<4)+RED;
  l->macro_attribute=(WHITE<<4)+LTBLUE;
  l->anchor_attribute=(WHITE<<4)+BLACK;
  l->hidden_attribute=(WHITE<<4)+BLACK;
  l->tree_attribute=(WHITE<<4)+PURPLE;
  l->user_attribute=(WHITE<<4)+GREEN;
  l->flags=0;
  l->dummy.next=l;
  l->dummy.last=l;
  l->bin_root.next=&l->bin_root;
  l->bin_root.last=&l->bin_root;
  l->undo_root.next=&l->undo_root;
  l->undo_root.last=&l->undo_root;
  l->undo_root.timestamp=0;
  l->undo_cnt=0;
  l->cur_bin_num=1;
  l->recalc_start=l;
  l->menu_ltf=NULL;
  l->dollar_buf_ptr=0;
  l->cmd_I1=CH_SPACE;
  l->indent=0;
  l->page_line_num=0;
  l->page_length=66;
  l->left_margin=LTF_DEFAULT;
  l->right_margin=LTF_DEFAULT;
  l->header=LTF_DEFAULT;
  l->footer=LTF_DEFAULT;
  l->best_d=MAX_I8;

  cl=&l->dummy;
  cl->type=LTFT_ERROR;
  cl->flags=0;
  cl->x=0;
  cl->y=0;
  cl->min_col=0;
  cl->max_col=0;
  cl->indent=l->indent;
  cl->page_line_num=l->page_line_num;
  cl->left_margin=l->left_margin;
  cl->right_margin=l->right_margin;

  LtfHome(l);
}


public void LtfDel(Ltf *l)
{
  Ltf *m;
  if (!l) return;
  m=l->menu_ltf;
  LtfReset(l,TRUE);
  Free(l->find_replace,l->mem_tss);
  Free(l->dollar_buf,l->mem_tss);
  LtfDel(m);
  Free(l,l->mem_tss);
}


void LtfFormatData(LtfEntry *cl)
{
  BoolU4 *b;
  U8 *d;
  I8 i;
  if (cl->btype==LTFT_DATA) {
    d=cl->data;
    if (cl->flags & LTFLF_DATA_IS_PTR)
      SPrintF(cl->display,cl->aux_str,*d,cl->my_format_data);
    else
      SPrintF(cl->display,cl->aux_str,d,cl->my_format_data);
    if (cl->flags & LTFLF_HAS_TERMINATOR) {
      i=StrLen(cl->display);
      cl->display[i++]='_';
      cl->display[i]=0;
    }
    cl->max_col=StrLen(cl->display);
  } else if (cl->btype==LTFT_CHECK_BOX) {
    if (cl->flags & LTFLF_DATA_IS_PTR)
      b=cl->data;
    else
      b=&cl->data;
    if (*b)
      cl->flags|=LTFLF_CHECKED;
    else
      cl->flags&=~LTFLF_CHECKED;
  }
}

void LtfGetData(LtfEntry *cl)
{
  BoolU4 *b;
  I8 i;
  if (cl->btype==LTFT_DATA) {
    i=StrLen(cl->display);
    if (cl->flags & LTFLF_HAS_TERMINATOR)
      cl->display[--i]=0;
    if (i>cl->len+cl->min_col)
      cl->display[cl->len+cl->min_col]=0;
    if (cl->flags & LTFLF_DATA_IS_PTR)
      GetF(cl->display,cl->aux_str,cl->data,cl->my_format_data);
    else
      GetF(cl->display,cl->aux_str,&cl->data,cl->my_format_data);
    if (cl->flags & LTFLF_HAS_TERMINATOR)
      cl->display[i]='_';
  } else if (cl->btype==LTFT_CHECK_BOX) {
    if (cl->flags & LTFLF_DATA_IS_PTR)
      b=cl->data;
    else
      b=&cl->data;
    if (cl->flags & LTFLF_CHECKED)
      *b=TRUE;
    else
      *b=FALSE;
  }
}

void LtfRemoveSoftCRs(Ltf *l=NULL,LtfEntry *cl=NULL)
{
  LtfEntry *cl2,*saved_cl=cl;
  BoolU4 old_preempt=Preempt(OFF);
  if (!l) {
    l=Fs->cur_ltf;
    if (!l) return;
  }
  if (!cl) cl=l->dummy.next;
  while (cl!=l) {
    cl2=cl->next;
    if (cl->btype==LTFT_SOFT_CR) {
      if (l->cur_entry==cl) {
	l->cur_entry=cl2;
	l->cur_data_col=l->cur_entry->min_col;
      }
      LtfDelEntry(l,cl);
    } else if (saved_cl && cl->btype==LTFT_CR)
      break;
    cl=cl2;
  }
  Preempt(old_preempt);
}

#help_index "Ltf/Cmd Line (Typically)"

public void LtfMax(U8 i=MAX_I4)
//Adjusts the size of the Ltf buffer.
//Normally, the command line deletes
//entries after a while.
{
  Ltf *l=Fs->cur_ltf;
  l->max_entries=i;
}

#help_index "Ltf"
public Ltf *LtfNew()
{
  Ltf *l;
  l=MAllocZ(sizeof(Ltf));
  StrCpy(l->filename.name,sys_temp_filename);
  l->file_attr=0;
  l->find_replace=MAllocZ(sizeof(EditFindTextStruct));
  l->find_replace->scan_forward=1;
  l->find_replace->match_case=1;
  l->LeftClickLink=&EditLeftClickLink;
  l->dollar_buf_size=84;
  l->dollar_buf=MAlloc(l->dollar_buf_size);
  l->max_entries=MAX_I4;
  l->ww_lines_back=32;
  l->win_tss=Fs;
  l->mem_tss=Fs;
  LtfReset(l,FALSE);
  return l;
}

sys_clipboard_ltf=LtfNew;

