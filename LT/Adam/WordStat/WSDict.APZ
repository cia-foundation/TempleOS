I8 WsdNextCmd(I1 **ptr_)
{
  I8 result=-1;
  I1 ch,*ptr=*ptr_,*ptr2;
  do {
    do {
      if (!(ch=*ptr++)) goto done;
    } while (ch!='<');

    ptr2=ptr;
    do {
      if (!(ch=*ptr2++)) goto done;
    } while (ch!='>');
    *--ptr2=0;
    result=MatchListEntry(ptr,"h1\0/h1\0def\0/def\0hw\0/hw\0tt\0/tt\0"
"ety\0@fld\0@cd\0@blockquote\0@wordforms\0@note\0@altname\0@chform\0@cref\0@syn\0"
"/ety\0@/fld\0@/cd\0@/blockquote\0@/wordforms\0@/note\0@/altname\0@/chform\0@/cref\0@/syn\0");
    *ptr2++='>';
    ptr=ptr2;
  } while (result<0);

done:
  *ptr_=ptr;
  return result;
}

I1 *WsdNextEntry(I1 **ptr_)
{
  I1 *ignore,*result,ch,*ptr=*ptr_,buf[WSD_BLK_SIZE],*out_ptr=buf;
  I8 l;
  do {
    do {
      if (!(ch=*ptr++)) goto done;
      if (ch!='<') {
	*out_ptr++=ch;
	if (ch=='$$')
	  *out_ptr++=ch;
      } else
	break;
    } while (TRUE);
    ignore="b>\0i>\0p>\0/b>\0/i>\0/p>\0"
       "ets>\0col>\0spn>\0/ets>\0/col>\0/spn>\0er>\0as>\0cs>\0cd>\0ex>\0"
       "/er>\0/as>\0/cs>\0/cd>\0/ex>\0"
       "note>\0/note>\0blockquote>\0/blockquote>\0";
    while (*ignore) {
      l=StrLen(ignore);
      if (!StrNCmp(ptr,ignore,l)) {
	ptr+=l;
	break;
      } else
	ignore+=l+1;
    }
    if (!*ignore)
      break;
  } while (TRUE);
done:
  *out_ptr++=0;
  result=NewStr(buf);
  *ptr_=ptr-1;
  return result;
}

I8 WsdCompareWords(I1 **e1,I1 **e2)
{
  return StrCmp(*e1,*e2);
}

I1 *WsdSortWords(I1 *start,I8 size,I8 word_cnt)
{
  I1 **ptr_array=MAlloc(sizeof(void *)*word_cnt),
     *out_start=MAlloc(size),
     *ptr=start,*ptr2;
  I8 i=0;
  while (*ptr) {
    ptr_array[i++]=ptr;
    ptr+=StrLen(ptr)+3;
  }
  coutln "Sorting...";	Sleep(100);
  QSort(ptr_array,word_cnt,sizeof(void *),&WsdCompareWords);
  coutln "Done..."; Sleep(100);

  ptr=out_start;
  for (i=0;i<word_cnt;i++) {
    ptr2=ptr_array[i];
    while (*ptr2)
      *ptr++=*ptr2++;
    *ptr++=*ptr2++; //zero
    *ptr++=*ptr2++; //blk lo
    *ptr++=*ptr2++; //blk hi
  }
  *ptr++=0;
  return out_start;
}


void WsdCmpRawDictFile()
{
  I8 cmd,size,word_cnt=0,largest_entry=0;
  I1 *st,*in_ptr=ReadFile(WSD_RAW_FILENAME,&size),*in_start=in_ptr,
     *out_ptr=MAlloc(size),*out_start=out_ptr,
     *word_ptr=MAlloc(size),*word_start=word_ptr,
     *last_word=NULL,*def_word_start=out_ptr,
     *sorted_word_start;
  U2 *d;

  do {
    cmd=WsdNextCmd(&in_ptr);
    if (cmd==WSD_H1) {
next_word:
      if (out_ptr-def_word_start>largest_entry)
	largest_entry=out_ptr-def_word_start;
      def_word_start=out_ptr;
      if (st=WsdNextEntry(&in_ptr)) {
	if (*st) {
	  if (StrICmp(st,last_word)) {
	    word_cnt++;

	    *word_ptr++=WSD_WORD_CHAR;
	    last_word=word_ptr;
	    StrCpy(word_ptr,st);
	    word_ptr+=StrLen(st)+1;

	    d=word_ptr;
	    *d=(out_ptr-out_start)/WSD_BLK_SIZE;
	    word_ptr+=2;
 
	    *out_ptr++=WSD_WORD_CHAR;
	    StrCpy(out_ptr,st);
	    out_ptr+=StrLen(st)+1;
	  }
	  Free(st);

	  do {
	    do {
	      cmd=WsdNextCmd(&in_ptr);
	      if (cmd==WSD_H1)
		goto next_word;
	    } while (cmd>=0 && !(cmd==WSD_DEF||cmd==WSD_PRONUNCIATION||cmd==WSD_POS||cmd==WSD_EXTRA));
	    if (cmd==WSD_DEF) {
	      if(st=WsdNextEntry(&in_ptr)) {
		if (*st) {
		  *out_ptr++=WSD_DEF_CHAR;
		  StrCpy(out_ptr,st);
		  out_ptr+=StrLen(st)+1;
		}
		Free(st);
	      }
	    } else if (cmd==WSD_PRONUNCIATION) {
	      if(st=WsdNextEntry(&in_ptr)) {
		if (*st) {
		  *out_ptr++=WSD_PRONUNCIATION_CHAR;
		  StrCpy(out_ptr,st);
		  out_ptr+=StrLen(st)+1;
		}
		Free(st);
	      }
	    } else if (cmd==WSD_POS) {
	      if(st=WsdNextEntry(&in_ptr)) {
		if (*st) {
		  *out_ptr++=WSD_POS_CHAR;
		  StrCpy(out_ptr,st);
		  out_ptr+=StrLen(st)+1;
		}
		Free(st);
	      }
	    } else if (cmd==WSD_EXTRA) {
	      if(st=WsdNextEntry(&in_ptr)) {
		if (*st) {
		  *out_ptr++=WSD_EXTRA_CHAR;
		  StrCpy(out_ptr,st);
		  out_ptr+=StrLen(st)+1;
		}
		Free(st);
	      }
	    }
	  } while (cmd==WSD_DEF||cmd==WSD_PRONUNCIATION||cmd==WSD_POS||cmd==WSD_EXTRA);
	} else
	  Free(st);
      }
    }
  } while (cmd>=0);
  *out_ptr++=WSD_END_CHAR;
  *word_ptr++=WSD_END_CHAR;

  Free(in_start);

  PrintF("Blk Size      :%d\r\n",WSD_BLK_SIZE);
  PrintF("Blk Cnt       :%04X\r\n",(out_ptr-out_start+WSD_BLK_SIZE-1)/WSD_BLK_SIZE);
  PrintF("Largest Entry :%d\r\n",largest_entry);
  PrintF("Word Count    :%d\r\n",word_cnt);

  WriteFile(WSD_DEF_FILENAME,out_start,out_ptr-out_start);
  PrintF("Def File Size :%d\r\n",out_ptr-out_start);

  sorted_word_start=WsdSortWords(word_start,word_ptr-word_start,word_cnt);
  WriteFile(WSD_WORD_FILENAME,sorted_word_start,word_ptr-word_start);
  PrintF("Word File Size:%d\r\n",word_ptr-word_start);

  Free(out_start);
  Free(word_start);
  Free(sorted_word_start);
}


public void WsdLoadWords()
{
  I8 size;
  SysHashEntry *temph;
  I1 *in_ptr,*in_start,*st2;
  U2 *d;
  ws_dict_num_words=0;
  if (in_ptr=ReadFile(WSD_WORD_FILENAME,&size)) {
    in_start=in_ptr;
    ws_dict_word_list=AMAlloc(size);
    MemCpy(ws_dict_word_list,in_start,size);
    ws_dict_word_list_size=size;

    while (in_ptr<in_start+size) {
      if (*in_ptr==WSD_WORD_CHAR)
	in_ptr++;
      if (*in_ptr) {
	st2=MStrUtil(in_ptr,SU_TO_UPPER);
	temph=AMAllocZ(sizeof(SysHashEntry)+StrLen(st2)+1);
	StrCpy(temph+sizeof(SysHashEntry),st2);
	Free(st2);
	in_ptr+=StrLen(in_ptr)+1;
	temph->str=temph+sizeof(SysHashEntry);
	temph->use_cnt=1;
	temph->type=HTT_DICT_WORD;
	d=in_ptr;
	temph->user_data0=*d;
	in_ptr+=2;
	AddSysHashEntry(temph,ws_hash_table);
	ws_dict_num_words++;
      } else
	in_ptr+=3;
    }
    Free(in_start);
  }
}


public I1 *WsdGetDef(I1 *st,I8 def_num=1)
{
  LTFile *f;
  SysHashEntry *temph;
  I1 *result=NULL,*buf,*in_ptr;
  I1 *st2=MStrUtil(st,SU_TO_UPPER);
  temph=FindHashEntry(st2,ws_hash_table,HTT_DICT_WORD);
  Free(st2);
  if (temph) {
    if (f=FOpen(WSD_DEF_FILENAME,"r")) {
      buf=MAlloc(WSD_BLK_SIZE*2+1);
      buf[WSD_BLK_SIZE*2]=0; //terminate
      FRBlks(f,buf,temph->user_data0*WSD_BLK_SIZE/BLK_SIZE,WSD_BLK_SIZE*2/BLK_SIZE);
      FClose(f);
      in_ptr=buf;
      while (in_ptr<buf+WSD_BLK_SIZE*2) {
	while (*in_ptr!=WSD_WORD_CHAR && in_ptr<buf+WSD_BLK_SIZE*2)
	  in_ptr++;
	if (*in_ptr++==WSD_WORD_CHAR) {
	  if (!StrICmp(st,in_ptr)) {
	    while (def_num && *in_ptr!=WSD_WORD_CHAR
		   && in_ptr<buf+WSD_BLK_SIZE*2) {
	      if (*in_ptr==WSD_DEF_CHAR) {
		if (!--def_num)
		  break;
		else
		  in_ptr++;
	      } else
		in_ptr++;
	    }
	    if (*in_ptr++==WSD_DEF_CHAR) {
	      result=NewStr(in_ptr);
	      break;
	    }
	  }
	}
      }
      Free(buf);
    }
  }
  return result;
}

public I1 *WsdGetWord(I1 *st)
{
  LTFile *f;
  SysHashEntry *temph;
  I1 *result=NULL,*buf,*in_ptr,*in_ptr2;
  I1 *st2=MStrUtil(st,SU_TO_UPPER);
  temph=FindHashEntry(st2,ws_hash_table,HTT_DICT_WORD);
  Free(st2);
  if (temph) {
    if (f=FOpen(WSD_DEF_FILENAME,"r")) {
      buf=MAlloc(WSD_BLK_SIZE*2+1);
      buf[WSD_BLK_SIZE*2]=0; //terminate
      FRBlks(f,buf,temph->user_data0*WSD_BLK_SIZE/BLK_SIZE,WSD_BLK_SIZE*2/BLK_SIZE);
      FClose(f);
      in_ptr=buf;
      while (in_ptr<buf+WSD_BLK_SIZE*2) {
	while (*in_ptr!=WSD_WORD_CHAR && in_ptr<buf+WSD_BLK_SIZE*2)
	  in_ptr++;
	if (*in_ptr++==WSD_WORD_CHAR) {
	  if (!StrICmp(st,in_ptr)) {
	    in_ptr2=in_ptr;
	    in_ptr--;
	    while (*in_ptr2!=WSD_WORD_CHAR
		   && in_ptr2<buf+WSD_BLK_SIZE*2) {
	      in_ptr2++;
	    }
	    result=MAlloc(in_ptr2+1-in_ptr);
	    MemCpy(result,in_ptr,in_ptr2-in_ptr);
	    result[in_ptr2-in_ptr]=WSD_END_CHAR;
	    break;
	  }
	}
      }
      Free(buf);
    }
  }
  return result;
}


public I1 *WsdPointAtWord(I1 *st,U8 n=0)
{
  I1 *r=NULL,*r1,
     *start=ws_dict_word_list,
     *end=ws_dict_word_list+ws_dict_word_list_size;
  if (!st)
    return NULL;
  if (!*st)
    return ws_dict_word_list;
  if (ws_dict_word_list_size) {
    if (!n) n=StrLen(st);
    while (start<end-4) {
      r1=(start+end)>>1;
      r=r1;
      while (*r!=WSD_WORD_CHAR && r>ws_dict_word_list)
	r--;
      if (r[2]==WSD_WORD_CHAR)
	r+=2;
      else
	if (r[1]==WSD_WORD_CHAR)
	  r++;
      if (*r==WSD_WORD_CHAR)
	r++;
      if (StrNICmp(st,r,n)<=0)
	end=r1;
      else
	start=r1;
    }
    if (r>ws_dict_word_list)
      r--;
  }
  return r;
}


void WsdAddDictWords(Ltf *l,I1 *st=NULL)
{
  I8 i;
  I1 *ptr;
  if (!st)
    st=ws_cur_word;
  if (st) {
    if (ptr=WsdPointAtWord(st)) {
      for (i=0;i<WSD_MAX_FILLINS;i++) {
	if (*ptr++!=WSD_WORD_CHAR)
	  break;
	wsd_fillins[i]=ptr-1;
	LtfPrintF(l," '%d' %-20ts\r\n",i,ptr);
	ptr+=StrLen(ptr)+3;
      }
      wsd_num_fillins=i;
    }
  }
}

void WsdFillin(I8 n)
{
  I1 *s;
  I8 len;
  if (n>=0 && n<wsd_num_fillins) {
    s=wsd_fillins[n]+1;
    len=StrLen(s);
    if (len>ws_partial_len)
      Auto(s+ws_partial_len);
  }
}


public void WsdDisplayDefs(Ltf *l,I1 *st,I8 num=-1)
{
  I1 *st2,*st3,ch;
  I8 i=0;
  if (!st) return;
  if (*st==WSD_WORD_CHAR)
    st++;
  LtfPrintF(l,"$$WW,1$$$$FG,RED$$%s:$$FG$$\r\n\r\n",st);
  if (num<0) {
    if (st3=WsdGetWord(st)) {
      st2=st3;
      while (ch=*st2++) {
	switch (ch) {
	  case WSD_WORD_CHAR:
	    break;
	  case WSD_DEF_CHAR:
	    LtfPrintF(l,"$$FG,GREEN$$(%d)$$FG$$ %s\r\n",
	      ++i,st2);
	    break;
	  case WSD_PRONUNCIATION_CHAR:
	    LtfPrintF(l,"$$FG,LTGREEN$$%s$$FG$$\r\n",st2);
	    break;
	  case WSD_POS_CHAR:
	    LtfPrintF(l,"$$FG,BLACK$$%s$$FG$$\r\n",st2);
	    break;
	  case WSD_EXTRA_CHAR:
	    LtfPrintF(l,"$$FG,LTBLUE$$%s$$FG$$\r\n",st2);
	    break;
	}
	st2+=StrLen(st2)+1;
      }
      Free(st3);
    }
  } else {
    while (st2=WsdGetDef(st,++i)) {
      if (i==num)
	LtfPrintF(l,"$$FG,GREEN$$(%d)$$FG$$ %s\r\n",
	  i,st2);
      Free(st2);
    }
  }
}

void WsdPopUpDef(I1 *st,I8 num=-1,TssStruct *parent=NULL)
{
  I1 *buf;
  buf=MSPrintF("WsdDisplayDefs(Fs->cur_ltf,\"%s\",%d);View;",st,num);
  PopUp(buf,parent);
  Free(buf);
}

void WsdDef(I8 n,TssStruct *parent=NULL)
{
  if (n>=0 && n<wsd_num_fillins)
    WsdPopUpDef(wsd_fillins[n],-1,parent);
}

