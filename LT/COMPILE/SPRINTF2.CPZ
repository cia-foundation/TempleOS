void OutChar(I1 **addr_dst,I1 ch,I1 **addr_buf)
{
  I8 i;
  I1 *dst=*addr_dst,*buf;
  if (addr_buf) {
    buf=*addr_buf;
    i=dst-buf;
    if (i>=MSize(buf)) {
      buf=MAlloc(i<<1+1);
      MemCpy(buf,*addr_buf,i);
      dst=buf+i;
      *addr_buf=buf;
    }
  }
  *dst++=ch;
  *addr_dst=dst;
}

void OutString(I1 *ptr,I1 **addr_buf,I1 *addr_dst,
     I8 len,BoolU4 left_justify,BoolU4 truncate)
{
  I8 i,j;
  i=StrLen(ptr);
  if (truncate && i>len)
    i=len;
  if (left_justify) {
    for (j=0;j<i;j++)
      OutChar(addr_dst,*(ptr++),addr_buf);
    for (j=0;j<len-i;j++)
      OutChar(addr_dst,CH_SPACE,addr_buf);
  } else {
    for (j=0;j<len-i;j++)
      OutChar(addr_dst,CH_SPACE,addr_buf);
    for (j=len-i;j<len;j++)
      OutChar(addr_dst,*(ptr++),addr_buf);
  }
}

I1 *MSPrintFPSect(U8 add,U8 field_length)
{
  U8 offset;
  SysHashEntry *temph;
  if (temph=FindPSect(add,&offset)) {
    if (offset<=0xFFFF) {
      if (field_length>5)
	return MSPrintF("%*ts,%04X",field_length-5,temph->string,offset);
      else
	return MSPrintF("%s,%04X",temph->string,offset);
    }
  }
  if (field_length)
    return MSPrintF("%*tX",field_length,add);
  else
    return MSPrintF("%X",add);
}

I1 *MSPrintFTime(LTDate ltdt,U8 sub_format)
{
  LTDateStruct d;
  ToLTDateStruct(&d,ltdt);
  switch (sub_format) {
    case 1:
      return MSPrintF("%02d:%02d",d.hours,d.minutes);
    case 2:
      if (d.hours>=12)
	return MSPrintF("%02d:%02d:%02d pm",d.hours-12,d.minutes,d.seconds);
      else
	return MSPrintF("%02d:%02d:%02d am",d.hours,d.minutes,d.seconds);
    case 3:
      if (d.hours>=12)
	return MSPrintF("%02d:%02d pm",d.hours-12,d.minutes);
      else
	return MSPrintF("%02d:%02d am",d.hours,d.minutes);
    case 4:
      if (d.hours>=12)
	return MSPrintF("%02d:%02d:%02dp",d.hours-12,d.minutes,d.seconds);
      else
	return MSPrintF("%02d:%02d:%02da",d.hours,d.minutes,d.seconds);
    case 5:
      if (d.hours>=12)
	return MSPrintF("%02d:%02dp",d.hours-12,d.minutes);
      else
	return MSPrintF("%02d:%02da",d.hours,d.minutes);
    case 6:
      return MSPrintF("%dh %02dm",d.hours+ltdt.date*24,d.minutes);
    case 7:
      return MSPrintF("%dh %02dm %02ds",d.hours+ltdt.date*24,d.minutes,d.seconds);
    case 8:
      return MSPrintF("%dd %02dh %02dm",ltdt.date,d.hours,d.minutes);
    case 9:
      return MSPrintF("%dd %02dh %02dm %02ds",ltdt.date,d.hours,d.minutes,d.seconds);
    case 10:
      return MSPrintF("%dd %02dh %02dm %02d.%02ds",ltdt.date,d.hours,d.minutes,d.seconds,d.hundredths);
    case 11:
      return MSPrintF("%dh %02dm %02d.%02ds",d.hours+ltdt.date*24,d.minutes,d.seconds,d.hundredths);
    case 12:
      return MSPrintF("%d.%02d",MulU8(60,(ltdt.date*24+d.hours)*60+d.minutes)+d.seconds,d.hundredths);
    case 13:
      return MSPrintF("%02d:%02d.%02d",MulU8(60,ltdt.date*24+d.hours)+d.minutes,d.seconds,d.hundredths);
    case 14:
      return MSPrintF("%02d:%02d:%02d.%02d",ltdt.date*24+d.hours,d.minutes,d.seconds,d.hundredths);
    case 15:
      return MSPrintF("%dd %02dh %02dm %02d.%04ds",ltdt.date,d.hours,d.minutes,d.seconds,d.ten_thousandths);
    case 16:
      return MSPrintF("%dh %02dm %02d.%04ds",d.hours+ltdt.date*24,d.minutes,d.seconds,d.ten_thousandths);
    case 17:
      return MSPrintF("%d.%04d",MulU8(60,(ltdt.date*24+d.hours)*60+d.minutes)+d.seconds,d.ten_thousandths);
    case 18:
      return MSPrintF("%02d:%02d.%04d",MulU8(60,ltdt.date*24+d.hours)+d.minutes,d.seconds,d.ten_thousandths);
    case 19:
      return MSPrintF("%02d:%02d:%02d.%04d",ltdt.date*24+d.hours,d.minutes,d.seconds,d.ten_thousandths);
    default:
      return MSPrintF("%02d:%02d:%02d",d.hours,d.minutes,d.seconds);
  }
}

I1 *MSPrintFDate(U8 dt,U8 sub_format)
{
  LTDateStruct d;
  LTDate ltdt=0;
  ltdt.date=dt;
  ToLTDateStruct(&d,ltdt);
  switch (sub_format) {
    case 1:
      return MSPrintF("%02d/%02d",d.month,d.day_of_month);
    case 2:
      return MSPrintF("%3tZ %02d/%02d",d.day_of_week,"ST_DAYS_OF_WEEK",
	d.month,d.day_of_month);
    case 3:
      return MSPrintF("%3tZ %02d/%02d/%02d",d.day_of_week,"ST_DAYS_OF_WEEK",
	d.month,d.day_of_month,(d.year)%100);
    case 4:
      return MSPrintF("%02d/%02d/%d",d.month,d.day_of_month,d.year);
    case 5:
      return MSPrintF("%3tZ %02d/%02d/%d",d.day_of_week,"ST_DAYS_OF_WEEK",
	d.month,d.day_of_month,d.year);
    case 6:
      return MSPrintF("%3tZ %02d",d.month-1,"ST_MONTHS",d.day_of_month);
    case 7:
      return MSPrintF("%3tZ, %3tZ %02d",d.day_of_week,"ST_DAYS_OF_WEEK",
	d.month-1,"ST_MONTHS",d.day_of_month);
    case 8:
      return MSPrintF("%3tZ %02d,%04d",d.month-1,"ST_MONTHS",d.day_of_month,d.year);
    case 9:
      return MSPrintF("%3tZ, %3tZ %02d,%d",d.day_of_week,"ST_DAYS_OF_WEEK",
	d.month-1,"ST_MONTHS",d.day_of_month,d.year);
    case 10:
      return MSPrintF("%Z %d",d.month-1,"ST_MONTHS",d.day_of_month);
    case 11:
      return MSPrintF("%Z, %Z %d",d.day_of_week,"ST_DAYS_OF_WEEK",
	d.month-1,"ST_MONTHS",d.day_of_month);
    case 12:
      return MSPrintF("%Z %d,%d",d.month-1,"ST_MONTHS",d.day_of_month,d.year);
    case 13:
      return MSPrintF("%Z, %Z %d,%d",d.day_of_week,"ST_DAYS_OF_WEEK",
	d.month-1,"ST_MONTHS",d.day_of_month,d.year);
    case 14:
      return MSPrintF("%02d/%02d/%02d",d.day_of_month,d.month,(d.year)%100);
    case 15:
      return MSPrintF("%02d/%02d",d.day_of_month,d.month);
    case 16:
      return MSPrintF("%3tZ %02d/%02d",d.day_of_week,"ST_DAYS_OF_WEEK",
	d.day_of_month,d.month);
    case 17:
      return MSPrintF("%3tZ %02d/%02d/%02d",d.day_of_week,"ST_DAYS_OF_WEEK",
	d.day_of_month,d.month,(d.year)%100);
    case 18:
      return MSPrintF("%02d/%02d/%d",d.day_of_month,d.month,d.year);
    case 19:
      return MSPrintF("%3tZ %02d/%02d/%d",d.day_of_week,"ST_DAYS_OF_WEEK",
	d.day_of_month,d.month,d.year);
    case 20:
      return MSPrintF("%02d %3tZ",d.day_of_month,d.month-1,"ST_MONTHS");
    case 21:
      return MSPrintF("%3tZ, %02d %3tZ",d.day_of_week,"ST_DAYS_OF_WEEK",
	d.day_of_month,d.month-1,"ST_MONTHS");
    case 22:
      return MSPrintF("%02d %3tZ,%04d",d.day_of_month,d.month-1,"ST_MONTHS",d.year);
    case 23:
      return MSPrintF("%3tZ, %02d %3tZ,%d",d.day_of_week,"ST_DAYS_OF_WEEK",
	d.day_of_month,d.month-1,"ST_MONTHS",d.year);
    case 24:
      return MSPrintF("%d %Z",d.day_of_month,d.month-1,"ST_MONTHS");
    case 25:
      return MSPrintF("%Z, %d %Z",d.day_of_week,"ST_DAYS_OF_WEEK",
	d.day_of_month,d.month-1,"ST_MONTHS");
    case 26:
      return MSPrintF("%d %Z,%d",d.day_of_month,d.month-1,"ST_MONTHS",d.year);
    case 27:
      return MSPrintF("%Z, %d %Z,%d",d.day_of_week,"ST_DAYS_OF_WEEK",
	d.day_of_month,d.month-1,"ST_MONTHS",d.year);
    case 28:
      return MSPrintF("%02d/%02d/%02d",(d.year)%100,d.month,d.day_of_month);
    case 29:
      return MSPrintF("%d/%02d/%02d",d.year,d.month,d.day_of_month);
    case 30:
      return MSPrintF("%02d%02d%02d",(d.year)%100,d.month,d.day_of_month);
    case 31:
      return MSPrintF("%d%02d%02d",d.year,d.month,d.day_of_month);
    case 32:
      return MSPrintF("%02d%02d%02d",d.month,d.day_of_month,(d.year)%100);
    case 33:
      return MSPrintF("%02d%02d%d",d.month,d.day_of_month,d.year);
    case 34:
      return MSPrintF("%3tZ",d.day_of_week,"ST_DAYS_OF_WEEK");
    case 35:
      return MSPrintF("%Z",d.day_of_week,"ST_DAYS_OF_WEEK");
    case 36:
      return MSPrintF("%3tZ",d.month-1,"ST_MONTHS");
    case 37:
      return MSPrintF("%Z",d.month-1,"ST_MONTHS");
    case 38:
      return MSPrintF("%d %3tZ",d.year,d.month-1,"ST_MONTHS");
    case 39:
      return MSPrintF("%d %Z",d.year,d.month-1,"ST_MONTHS");
    case 40:
      return MSPrintF("%02d %3tZ",(d.year)%100,d.month-1,"ST_MONTHS");
    case 41:
      return MSPrintF("%02d %Z",(d.year)%100,d.month-1,"ST_MONTHS");
    case 42:
      return MSPrintF("%3tZ %d",d.month-1,"ST_MONTHS",d.year);
    case 43:
      return MSPrintF("%Z %d",d.month-1,"ST_MONTHS",d.year);
    case 44:
      return MSPrintF("%3tZ %02d",d.month-1,"ST_MONTHS",(d.year)%100);
    case 45:
      return MSPrintF("%Z %02d",d.month-1,"ST_MONTHS",(d.year)%100);
    case 46:
      return MSPrintF("%02d",(d.year)%100);
    case 47:
      return MSPrintF("%d",d.year);
    default:
      return MSPrintF("%02d/%02d/%02d",d.month,d.day_of_month,(d.year)%100);
  }
}

I1 *SPrintFJoin2(I1 *dst,I1 *src,I8i argc,I8i *argv)
{
  I1 ch,*ptr,**addr_buf,*buf=NULL,*addr_dst,
       *temp1;
  BoolU4 pad_zero,left_justify,truncate,neg,neg_e;
  I8 i;
  I8 k,len,dec_len,sub_format;
  U8 d,cur_param=0;
  double dd,dd1,*dd_ptr;
  I1 temp_buf[80];
  argc; //ref so no warning
  if (dst) {
    addr_buf=NULL;
  } else {
    buf=MAlloc(256);
    addr_buf=&buf;
    dst=buf;
  }
  addr_dst=&dst;

  while (ch = *(src++)) {
    if (ch=='%') {
      if (*src=='-') {
	left_justify=TRUE;
	src++;
      } else
	left_justify=FALSE;
      if (*src=='0') {
	pad_zero=TRUE;
	src++;
      } else
	pad_zero=FALSE;
      len=0;
      while (*src>='0' && *src<='9')
	len=len*10+ *(src++)-'0';
      if (*src=='*') {
	src++;
	len=argv[cur_param++];
      }
      dec_len=0;
      if (*src=='.') {
	src++;
	while (*src>='0' && *src<='9')
	  dec_len=dec_len*10+ *(src++)-'0';
	if (*src=='*') {
	  src++;
	  dec_len=argv[cur_param++];
	}
      }
      if (*src=='t') {
	src++;
	truncate=TRUE;
      } else
	truncate=FALSE;

      sub_format=0;
      if (*src=='h') {
	src++;
	while (*src>='0' && *src<='9')
	  sub_format=sub_format*10+ *(src++)-'0';
	if (*src=='*') {
	  src++;
	  sub_format=argv[cur_param++];
	}
      }
      neg=FALSE;
      k=0;
      switch (*src++) {
	case 's':
	  ptr=argv[cur_param++];
	  OutString(ptr,addr_buf,addr_dst,len,left_justify,truncate);
	  break;
	case 'S':
	  ptr=SysText(argv[cur_param++]);
	  OutString(ptr,addr_buf,addr_dst,len,left_justify,truncate);
	  break;
	case 'F':
	  ptr=ReadTextFile(argv[cur_param++]);
	  if (ptr) {
	    OutString(ptr,addr_buf,addr_dst,len,left_justify,truncate);
	    Free(ptr);
	  }
	  break;
	case 'Q':
	  ptr=argv[cur_param++];
	  while (ch=*ptr++) {
	    if (ch=='$$') {
	      OutChar(addr_dst,ch,addr_buf);
	      OutChar(addr_dst,ch,addr_buf);
	    } else if (ch==CH_LINE_FEED){
	      OutChar(addr_dst,'\\',addr_buf);
	      OutChar(addr_dst,'n',addr_buf);
	    } else if (ch==CH_CR){
	      OutChar(addr_dst,'\\',addr_buf);
	      OutChar(addr_dst,'r',addr_buf);
	    } else if (ch==CH_TAB){
	      OutChar(addr_dst,'\\',addr_buf);
	      OutChar(addr_dst,'t',addr_buf);
	    } else {
	      if (ch=='"' || ch=='\\')
		OutChar(addr_dst,'\\',addr_buf);
	      OutChar(addr_dst,ch,addr_buf);
	    }
	  }
	  break;
	case 'z':
	  ptr=PointAtListEntry(argv[cur_param],argv[cur_param+1]);
	  cur_param=cur_param+2;
	  OutString(ptr,addr_buf,addr_dst,len,left_justify,truncate);
	  break;
	case 'Z':
 	  ptr=SysTextSub(argv[cur_param],argv[cur_param+1]);
	  cur_param=cur_param+2;
	  OutString(ptr,addr_buf,addr_dst,len,left_justify,truncate);
	  break;
	case 'c':
	  OutChar(addr_dst,argv[cur_param++],addr_buf);
	  break;
	case 'D':
	  temp1=MSPrintFDate(argv[cur_param++],sub_format);
	  OutString(temp1,addr_buf,addr_dst,len,left_justify,truncate);
	  Free(temp1);
	  break;
	case 'T':
	  temp1=MSPrintFTime(argv[cur_param++],sub_format);
	  OutString(temp1,addr_buf,addr_dst,len,left_justify,truncate);
	  Free(temp1);
	  break;
	case 'P':
	  if (truncate)
	    temp1=MSPrintFPSect(argv[cur_param++],len);
	  else
	    temp1=MSPrintFPSect(argv[cur_param++],0);
	  OutString(temp1,addr_buf,addr_dst,len,left_justify,truncate);
	  Free(temp1);
	  break;
	case 'd':
	  i=argv[cur_param++];
	  if (i<0) {
	    neg=TRUE;
	    i=-i;
	  }
	  while (!k || i) {
	    temp_buf[k++]=ModU8(i,10)+'0';
	    i=DivU8(i,10);
	  }
out_num:
	  i=(neg)? 1:0;
	  if (truncate && k+i>len)
	    k=len-i;
	  if (pad_zero)
	    for (;i<len-k;i++)
	      OutChar(addr_dst,'0',addr_buf);
	  else
	    for (;i<len-k;i++)
	      OutChar(addr_dst,32,addr_buf);
	  if (neg)
	    OutChar(addr_dst,'-',addr_buf);
	  for (i=k-1;i>=0;i--)
	    OutChar(addr_dst,temp_buf[i],addr_buf);
	  break;
	case 'u':
	  d=argv[cur_param++];
	  while (!k|| d) {
	    temp_buf[k++]=ModU8(d,10)+'0';
	    d=DivU8(d,10);
	  }
	  goto out_num;
	case 'f':
	  dd_ptr=&argv[cur_param++];
	  dd=*dd_ptr;
	  if (dd<0) {
	    neg=TRUE;
	    dd=-dd;
	  }
out_f:
	  if (i=dec_len)
	    dd*=Pow10(i);
	  dd=Round(dd);
	  while (i--) {
	    temp_buf[k++]=dd%10+'0';
	    dd=Floor(dd/10);
	  }
	  if (dec_len)
	    temp_buf[k++]='.';
	  do {
	    temp_buf[k++]=dd%10+'0';
	    dd=Floor(dd/10);
	  } while (dd);
	  goto out_num;
	case 'e':
	  if (!len) len=12;
	  dd_ptr=&argv[cur_param++];
	  dd=*dd_ptr;
	  if (dd<0) {
	    neg=TRUE;
	    dd=-dd;
	  }
	  dd1=(dd) ? Log10(dd):0;
	  dd1=Round(dd1);
out_e:
	  dd/=Pow10(dd1);
	  if (dd1<0) {
	    dd1=-dd1;
	    neg_e=TRUE;
	  } else
	    neg_e=FALSE;
	  if (dd) {
	    if (dd<1.0) {
	      dd*=10;
	      if (neg_e)
		dd1+=1;
	      else
		dd1-=1;
	    } else if (dd>=10.0) {
	      dd/=10;
	      if (neg_e)
		dd1-=1;
	      else
		dd1+=1;
	    }
	  }
	  i=3;
	  do {
	    temp_buf[k++]=dd1%10+'0';
	    dd1=Floor(dd1/10);
	  } while (dd1 && i--);
	  if (neg_e)
	    temp_buf[k++]='-';
	  temp_buf[k++]='e';
	  dec_len=len-k-neg-2;
	  goto out_f;
	case 'g':
	  if (!len) len=12;
	  dd_ptr=&argv[cur_param++];
	  dd=*dd_ptr;
	  if (dd<0) {
	    neg=TRUE;
	    dd=-dd;
	  }
	  dd1=(dd) ? Log10(dd):0;
	  dd1=Round(dd1);
	  if (dd1>=(len-1-dec_len) || dd1<-(dec_len-1))
	    goto out_e;
	  else
	    goto out_f;
	case 'X':
	  d=argv[cur_param++];
	  while (!k || d) {
	    temp_buf[k]=(d & 15)+'0';
	    if (temp_buf[k]>'9') temp_buf[k]+='A'-0x3A;
	    k++;
	    d>>=4;
	  }
	  goto out_num;
	case 'x':
	  d=argv[cur_param++];
	  while (!k || d) {
	    temp_buf[k]=(d & 15)+'0';
	    if (temp_buf[k]>'9') temp_buf[k]+='a'-0x3A;
	    k++;
	    d>>=4;
	  }
	  goto out_num;
	case 'b':
	  d=argv[cur_param++];
	  while (!k || d) {
	    temp_buf[k++]=(d&1)+'0';
	    d>>=1;
	  }
	  goto out_num;
	case '%':
	  OutChar(addr_dst,'%',addr_buf);
	  break;
      }
    } else
      OutChar(addr_dst,ch,addr_buf);
  }
  OutChar(addr_dst,0,addr_buf);
  return buf;
}


double A2Double(I1 *src,I1 **end_ptr=NULL)
{
  I1 ch=*src++;
  I8 i=0,j=0,k=0;
  double d;
  BoolU4 neg=FALSE;

  while (ch==CH_SPACE||ch==CH_TAB||ch==CH_SHIFT_SPACE)
    ch=*src++;
  if (ch=='-') {
    neg=TRUE;
    ch=*src++;
  }
  while (TRUE) {
    if (Bt(dec_numeric_bitmap,ch))
      i=MulU8(i,10)+ch-'0';
    else {
      if (ch=='.' || ch=='e' || ch=='E') break;
      d=i;
      goto a2d_end;
    }
    ch=*src++;
  }
  if (ch=='.')
    ch=*src++;
  while (TRUE) {
    if (Bt(dec_numeric_bitmap,ch)) {
      j=MulU8(j,10)+ch-'0';
      k++;
    } else {
      d=i+j*Pow10(-k);
      if (ch=='e' || ch=='E') break;
      goto a2d_end;
    }
    ch=*src++;
  }
  ch=*src++;
  k=1;
  if (ch=='-') {
    k=-1;
    ch=*src++;
  }
  j=0;
  while (TRUE) {
    if (Bt(dec_numeric_bitmap,ch))
      j=MulU8(j,10)+ch-'0';
    else {
      d*=Pow10(j*k);
      goto a2d_end;
    }
    ch=*src++;
  }
a2d_end:
  if (end_ptr) *end_ptr=src-1;
  return (neg) ? -d:d;
}

/*
A2LTDate()
  This routine recognizes the following formats:
  1) "*+nnnn"  "*-nnnnn"
  2) mm/dd
  3) mm/dd/yy
*/

LTDate A2LTDate(I1 *src2)
{
  LTDate result=0;
  LTDateStruct d,d1;
  I1 *src=MStringUtil(src2,SU_REMOVE_SPACES|SU_TO_UPPER),
     *v=NewString(src),
     *p1=src;
  BoolU4 start_month=FALSE,end_month=FALSE;
  BoolU4 start_year=FALSE,end_year=FALSE;

  MemSet(&d,0,sizeof(LTDateStruct));
  MemSet(&d1,0,sizeof(LTDateStruct));
  if (!StrNCmp(p1,"SM(",3)) {
    p1+=3;
    start_month=TRUE;
  } else if (!StrNCmp(p1,"EM(",3)) {
    p1+=3;
    end_month=TRUE;
  } else if (!StrNCmp(p1,"SY(",3)) {
    p1+=3;
    start_year=TRUE;
  } else if (!StrNCmp(p1,"EY(",3)) {
    p1+=3;
    end_year=TRUE;
  }
  if (*p1=='*') {
    p1++;
    if (*p1=='+' || *p1=='-')
      result.date=AtoI(p1,10,&p1);
    result+=GetCurTimeLTDate;
  } else {
    RemoveFirstSeg(p1,"/",v); //Put month into v
    d.month=AtoI(v);
    if (Occurrences(p1,'/')) {
      RemoveFirstSeg(p1,"/",v); //Put day into v leaving year in p1
      d.day_of_month=AtoI(v);
      d.year=AtoI(p1,10,&p1);
      if (d.year<100) //if not 4 digit year
	d.year+=2000;
    } else {
      d.day_of_month=AtoI(p1,10,&p1);
      ToLTDateStruct(&d1,GetCurTimeLTDate);
      d.year=d1.year;
    }
    result=ToLTDate(&d);
  }
  if (*p1==')') p1++;

  if (start_month)
    result.date=FirstDayOfMonth(result.date);
  else if (end_month)
    result.date=LastDayOfMonth(result.date);
  else if (start_year)
    result.date=FirstDayOfYear(result.date);
  else if (end_year)
    result.date=LastDayOfYear(result.date);

  if (*p1=='+' || *p1=='-')
    result.date+=AtoI(p1);
  Free(src);
  Free(v);
  return result;
}

void GetFJoin2(I1 *src,I1 *fmt,I8i argc,I8i *argv)
//Pass pointer to data,
//For %s pass pointer to pointer (be careful because address
//  of array is the same as array--create ptr to array and take address
{
  I1 ch,*buf,*ptr,**pptr;
  BoolU4 left_justify=FALSE;
  I8 cur_param=0,i,j,k,len,*i_ptr,sub_format=0,dec_len;
  double *d_ptr;
  argc; //ref so no warning
  while (ch = *(fmt++)) {
    if (ch=='%') {
      if (*fmt=='%') {
	src++;
	fmt++;
      } else {
	if (*fmt=='-') {
	  left_justify=TRUE;
	  fmt++;
	} else
	  left_justify=FALSE;
	len=0;
	while (*fmt>='0' && *fmt<='9')
	  len=len*10+ (*(fmt++)-'0');
	if (*fmt=='*') {
	  fmt++;
	  len=argv[cur_param++];
	}
	ch=*(fmt++);
	if (ch && !len) {
	  ptr=src;
	  while (*ptr && *ptr!=*fmt)
	    ptr++;
	  len=ptr-src;
	} else {
	  if (ch=='.') {
	    dec_len=0;
	    while (*fmt>='0' && *fmt<='9')
	      dec_len=dec_len*10+ (*(fmt++)-'0');
	    if (*fmt=='*') {
	      fmt++;
	      dec_len=argv[cur_param++];
	    }
	    ch=*(fmt++);
	  }
	}
	buf=MAlloc(len+1);
	for (i=0;i<len;i++)
	  buf[i]=*(src++);
	buf[i]=0;
	switch (ch) {
	  case 's':
	    pptr=argv[cur_param++];
	    StrCpy(*pptr,buf);
	    break;
	  case 'c':
	    ptr=argv[cur_param++];
	    *ptr=*buf;
	    break;
	  case 'z':
	    i_ptr=argv[cur_param++];
	    *i_ptr=MatchListEntry(buf,argv[cur_param++]);
	    break;
	  case 'Z':
	    i_ptr=argv[cur_param++];
	    *i_ptr=MatchSysTextEntry(buf,argv[cur_param++]);
	    break;
	  case 'd':
	    i_ptr=argv[cur_param++];
	    *i_ptr=0;
	    for (k=0;k<len;k++)
	      if (buf[k]!=32)
		*i_ptr=MulI8(*i_ptr,10)+(buf[k]-'0');
	    break;
	  case 'X':
	    i_ptr=argv[cur_param++];
	    *i_ptr=0;
	    for (k=0;k<len;k++)
	      if (buf[k]!=32) {
		j=ToUpper(buf[k])-'0';
		if (j>9)  j=j-'A'+('9'+1);
		*i_ptr=(*i_ptr<<4)+j;
	      }
	    break;
	  case 'b':
	    i_ptr=argv[cur_param++];
	    *i_ptr=0;
	    for (k=0;k<len;k++)
	      if (buf[k]!=32)
		*i_ptr=*i_ptr<<1+(buf[k]-'0');
	    break;
	  case 'e':
	  case 'f':
	  case 'g':
	    d_ptr=argv[cur_param++];
	    *d_ptr=A2Double(buf);
	    break;
	  case 'D':
	    i_ptr=argv[cur_param++];
	    *i_ptr=A2LTDate(buf)>>32;
	    break;
	}
	Free(buf);
      }
    } else
      src++;
  }
}


 