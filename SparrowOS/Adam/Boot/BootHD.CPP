asm {
#define MODULE_SIZE		1*BLK_SIZE
#define BOOT_HIGH_LOC	((BOOT_RAM_LIMIT-(BOOT_STK_SIZE+MODULE_SIZE))>>4)

USE16
BHD_START::
	DU8	0x5A DUP(0); //See $LK,"CFAT32Boot","MN:CFAT32Boot"$.code[]
BHD_CODE::
	CLD

	MOV	AX,VGA_TEXT_MEM_BASE/16
	MOV	FS,AX
	MOV	U32 FS:[4],0
	MOV	U32 FS:[0],'B'+0x2000+('3'+0x2000)<<16

	MOV	AX,BOOT_HIGH_LOC
	MOV	ES,AX

	CLI
	MOV	SS,AX
	MOV	SP,BOOT_STK_SIZE+MODULE_SIZE
	STI

	CALL	BHD_GET_IP
BHD_GET_IP:
	POP	BX
	SUB	BX,BHD_GET_IP-BHD_START
	SHR	BX,4
//Copy this bootloader code to just under 0x80000
	MOV	AX,CS
	ADD	AX,BX
	MOV	DS,AX
	MOV	CX,MODULE_SIZE
	XOR	SI,SI
	XOR	DI,DI
	REP_MOVSB

	MOV	AX,BOOT_HIGH_LOC
	MOV	DS,AX

//My assembler doesn't support 16-bit very well.
	DU8	0xEA;	//JMP BOOT_HIGH_LOC:BHD_HISTART
	DU16	BHD_HISTART-BHD_START,BOOT_HIGH_LOC;

BHD_BIOS_DRV_NUM: DU8	0;

//Gets patched by $LK,"InstallBoot","MN:InstallBoot"$().
BHD_BLK_CNT::	DU16	0;

BHD_DAP:	DU8	16,0,1,0; //One blk at a time
BHD_DAP_BUF:	DU16	0,0;
//Gets patched by $LK,"InstallBoot","MN:InstallBoot"$().
BHD_DAP_BLK::	//64-bit
BHD_DAP_BLK_LO:	DU32	0;
BHD_DAP_BLK_HI:	DU32	0;

BHD_HISTART:
	MOV	U8 [BHD_BIOS_DRV_NUM-BHD_START],DL //Passed in by BIOS
	MOV	AX,BOOT_RAM_BASE/16
	MOV	ES,AX
	XOR	ECX,ECX
	MOV	CX,U16 [BHD_BLK_CNT-BHD_START]

@@05:	PUSH	CX	//Blk cnt

//READ BLK
	PUSH	ES	//Buf seg
	MOV	AX,ES
	MOV	U16 [BHD_DAP_BUF+2-BHD_START],AX //ES:0000
	MOV	SI,BHD_DAP-BHD_START //DS:SI=DAP
	MOV	AH,0x42
	MOV	DL,U8 [BHD_BIOS_DRV_NUM-BHD_START]
	INT	0x13

	POP	AX	//ES
	ADD	AX,BLK_SIZE/16
	MOV	ES,AX
	INC	U32 [BHD_DAP_BLK_LO-BHD_START]
	JNZ	@@10
	INC	U32 [BHD_DAP_BLK_HI-BHD_START]

@@10:	POP	CX
	LOOP	@@05

	MOV	EBX,BOOT_CODE_HARDDRV //$MA+A-X+PU,"See sys_boot_code","Grep(\"sys_boot_code\",\"/SparrowOS/\"TEXT_FILE_MASK);View;\n"$
//My assembler doesn't support 16-bit very well.
	DU8	0xEA;	//JMP BOOT_RAM_BASE:0000
	DU16	0,BOOT_RAM_BASE/16;
//Continues here $LK,"::/SparrowOS/OSMain/OSStart.CPP.Z","FL:::/SparrowOS/OSMain/OSStart.CPP.Z,1"$
BHD_END::
#assert BHD_END-BHD_START<MODULE_SIZE-2
}